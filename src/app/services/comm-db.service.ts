import { Injectable } from '@angular/core';
import { AngularFirestore } from '@angular/fire/firestore';
import { AngularFireStorage } from '@angular/fire/storage'
import * as firebase from 'firebase/app'
import { FormControl, FormGroup } from '@angular/forms';


@Injectable({
  providedIn: 'root'
})
export class CommDbService {
  
  constructor(private afs: AngularFirestore,
              private afstorage: AngularFireStorage) {}

  //FormGroup for new added jobs
  newJobForm = new FormGroup({
    imageUrl: new FormControl(''),
    title: new FormControl(''),
    salary: new FormControl(''),
    introText: new FormControl(''),
    details: new FormControl(''),
    position: new FormControl(''),
    publishDateTime: new FormControl(''),
    lastEditDateTime: new FormControl(''),
    geolocation: new FormControl(''),
    tags: new FormControl('')
  });

  /**
   * Create a job into the firestore database, returns a promise
   * @param data the entire object of a newly added job, based on the @param newJobForm
   * @returns a promise indicating the result of the database operation
   */
  createJob(data){
    return this.afs.collection("Jobs").add(data);
  }

  /**
   * @returns a promise which will resolve all documents from the firestore collection "Jobs"
   */
  fetchJobList(){
    return this.afs.collection('Jobs').get().toPromise();
  }

  /**
   * Only fetch specific job documents based on the input job id array (The reason
   * why using transaction here is tring to use less data traffic than normal query,
   * but has never been tested)
   * @param jids an array of job id
   * @returns a promise indicates the result of the transaction
   */
  fetchPartialJobList(jids: string[]){
    var jobCollection = this.afs.firestore.collection("Jobs");
    return this.afs.firestore.runTransaction(
      transaction => {
        return new Promise<any>((resolve, reject) => {
          var tempList = [];
          var temp;
          jids.forEach(
            value => {
              transaction.get(jobCollection.doc(value)).then(
                res => {
                  temp = res.data();
                  temp["jid"] = value;
                  tempList.push(temp);
                }
              )
            }
          );
          return resolve(tempList);
        });
      });
  }

  /**
   * Fetch job documents that fits the user specified salary bounds.
   * @param range a object contains two attributes(upper: number, lower: number)
   * @returns a promise indicates the query result
   */
  fetchJobsByPay(range){
    return this.afs.collection('Jobs', ref => {
      return ref.where("salary", ">=", range.lower)
                .where("salary", "<=", range.upper)
                .orderBy("salary", "desc");
    }).get().toPromise();
  }
  
  /**
   * Called after a new user has been created by the FireAuth system, create
   * a correspond document in the firestore to store detailed customed information
   * @param uid the user id generated by the FireAuth system, which will be regarded
   * as the document id of the correspond userdoc
   * @param data the detailed data of a user(personal info, favourite jobs ...)
   * @returns a promise indicates the result of such db operation
   */
  createUserDoc(uid, data){
    return this.afs.collection("UserInfo").doc(uid).set(data);
  }

  /**
   * Update specific part of a userdoc document. Note that the @param data
   * should only contain the fileds which are required to be updated
   * (Because the query here will entirely overwrite all the mentioned
   * fields by the new data). To update a nested field please see
   * https://firebase.google.com/docs/firestore/manage-data/add-data?authuser=0.
   * Also, this method is not for updating a array field, please use
   * the @method updateUserDocArray intead.
   * @param uid the user uid
   * @param data the object that the user want to update
   */
  updateUserDoc(uid, data){
    return new Promise<any>((resolve, reject) => {
      this.afs.collection("UserInfo").doc(uid).update(data).then(
        res => {resolve(res); console.log("User doc updated", res)},
        err => reject(err)
      )
    });
  }

  /**
   * Update a userdoc array field, add/delete elements
   * @param uid the user id
   * @param field the field name
   * @param value the updated value
   * @param isAdd true for add
   * @returns a promise indicates the result of the update operation
   */
  updateUserDocArray(uid: string, field, value, isAdd: boolean){
    var updateObj = {};
    if(isAdd){
      updateObj[field] = firebase.firestore.FieldValue.arrayUnion(value)
    }else{
      updateObj[field] = firebase.firestore.FieldValue.arrayRemove(value)
    }
    return new Promise<any>((resolve, reject) => {
      this.afs.collection("UserInfo").doc(uid).update(updateObj).then(
        res => {resolve(res); console.log("User ",uid,field," update success")},
        err => {reject(err); console.log("User",uid,field," update failed")}
      );
    });
  }

  /**
   * Get a specific userdoc document
   * @param uid the user id
   * @returns a promise indicates the result of the query
   */
  fetchUserDoc(uid){
    return this.afs.collection("UserInfo").doc(uid).get().toPromise();
  }

  /**
   * Upload a file to the specified user folder
   * @param file the file object
   * @param uid the user id
   */
  async uploadFile(file: any, uid: string){
    var ref = this.afstorage.storage.ref("/").child(uid).child(file.name);
    var task = ref.put(file).then(
      res => console.log(res)
    );
  }

  /**
   * Get an array of one user's uploaded file paths
   * @param uid the user id
   * @returns an array of file paths
   */
  async listFiles(uid: string){
    var filePaths = [];
    var ref = this.afstorage.storage.ref(uid);
    await ref.listAll().then(
      res => {
        res.items.forEach(
          item => {
            filePaths.push(item.name);
          }
        );
      }
    ).catch(
      err => console.log("Error when fetch file list",err)
    );
    return filePaths;
  }

}